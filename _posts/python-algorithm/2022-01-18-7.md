---
title:  "리스트, 딕셔너리"
excerpt: "파이썬 알고리즘"

toc: true
toc_sticky: true
toc_label: "TOC"

categories:
  - python
  - algorithm
last_modified_at: 2022-01-18T13:30:00-50:00
---
리스트와 딕셔너리는 파이썬을 사용하면서 가장 번번하게 접하는 자료형이다.
이번에 구조, 원리, 문법에 대해 상세히 다뤄본다.

# 리스트 
리스트는 순서대로 저장하는 시퀸스이자 변경 가능한 목록을 말한다.  
입력 순서가 유지되며, 동적 배열로 구현되어 있다.  
파이썬 리스트는 다양한 기능을 제공한다는 점이 매우 큰 장점이다.  
이러한 점은 코딩 테스트에서 다른 언어에 비해 매우 유리한 조건을 갖는 셈이다.  

* 리스트의 주요 연산 시간 복잡도  

| 연산 | 시간 복잡도 | 설명 |
|--------|---------------|-----------|
| len(a) | O(1) | 전체 요소의 개수를 리턴한다. |
| a[i] | O(1) | 인덱스 i의 요소를 가져온다. |
| a[i:j]  | O(k) | i부터 j까지 슬라이스의 길이만큼인 k개의 요소를 가져온다.  이경우 객체 k를 조회하므로 O(k)이다. |
| elem in a | O(n) | elem 요소가 존재하는지 확인한다. 순차탐색으로 n만큼 걸린다. |
| a.count(elem) | O(n) | elem요소의 개수를 리턴한다. |
| a.index(elem) | O(n) | elem요소의 인덱스를 리턴한다. |
| a.append(elem) | O(1) | 리스트 마지막에 elem 요소를 추가한다. |
| a.pop() | O(1) | 리스트 마지막 요소를 추출한다. 스택 연산이다. |
| a.pop(0) | O(n) | 리스트 첫번째 요소를 추출한다. 큐의 연산이다. |
| del a[i] | O(n) | i에 따라 O()가 다르다. |
| a.sort() | O(n log n) | 팀소트를 사용하여 정렬한다. |
| min(a), max(a) | O(n) | 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다. |
| a.pop(0) | O(n) | 뒤집는다. |

## 리스트의 활용 방법
리스트의 간단한 활용 방법이다.  

```python
a = [1,2,3]
a.append(4) #[1,2,3,4]
a.insert(3,5) #[1,2,3,5,4]
a.append('안녕') #[1,2,3,5,4,'안녕'] 문자도 삽입가능
```

## 리스트의 특징
파이썬의 리스트는 다음과 같은 두가지의 형태를 보인다.
1. 연속된 공간에 요소를 배치하는 배열의 장점
2. 다양한 타입을 연결해 배치하는 연결 리스트의 장점

```cpp
typedef struct{
  PyObject_VAR_HEAD //매크로문이여서 세미콜론을 붙히지 않음
  Pyobject **ob_item;
  Py_ssize_t allocated;
} PyListObject;
```
CPython에서 리스트는 요소에 대한 대한 포인터 목록(ob_item)을 갖고 있는 구조체로 선언되어있다.
리스트에 요소를 추가하거나 조작하기 시작하면 ob_item의 사이즈를 조절해 나가는 형태로 구현되어 있다.
* 객체에 대한 포인터 목록으로 구현된 파이썬 리스트
![객체에 대한 포인터 목록으로 구현된 파이썬 리스트](/assets/images/python_list.jpg)

위와 같은 형태로 연결 리스트에 대한 포인터 목록을 배열 형태로 관리하고 있어 배열과 연결 리스트의 장점을 합친듯 한 기능을 자랑한다.  
하지만 인덱스를 조회하는 데에 모든 포인터의 위치를 찾아가서 타입 코드를 확인하고 값을 일일히 살펴봐야 함으로 속도 면에서 훨씬 불리하다.

# 딕셔너리
파이썬의 딕셔너리는 키/값 구조로 이뤄진 딕셔너리를 말한다. 내부적으로 해시 테이블로 구현되어 있다.

* 딕셔너리의 주요 연산 시간 복잡도  

| 연산 | 시간 복잡도 | 설명 |
|--------|---------------|-----------|
| len(a) | O(1) | 요소의 개수를 리턴한다. |
| a[key] | O(1) | 키를 조회하여 값을 리턴한다. |
| a[key] = value  | O(1) | 키/값을 삽입한다. |
| key in a | O(1) | 딕셔너리에 키가 존재하는지 확인한다. |

딕셔너리는 대부분의 연산이 O(1)에 처리 가능한 매우 우수한 자료형이다.  
3.7+에서 딕셔너리는 입력 순서가 유지된다. 하지만 인터프리터의 버전에 따라 순서유지가 되지 않을 수도 있으므로 권장하지 않는다.

## 딕셔너리의 활용방법
```python
a = {'key1':'value1', 'key2':'value2'}
a['key3'] = 'value3' # {'key1':'value1', 'key2':'value2', 'key3':'value3'}
for k,v in a.item(): #item()메소드를 사용하여 키와 값을 꺼내올 수 있다.
  print(k,v) # key1 value1
```

## 딕셔너리 모듈
딕셔너리와 관련된 특수한 형태의 컨테이너 자료형인 defaultdic, Counter, OrderedDict에 대해 알아본다.

### defaultdict객체
defaultdict 객체는 존재하지 않는 키를 조회할 경우, 에러 메세지를 출력하지않고 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다.
```python
a = collections.defaultdict(int)
a['A'] = 5
b['B'] = 4
print(a) #{'A': 5, 'B': 4}
```

### Counter 객체
Counter 객체는 아이템의 개수를 계산해 딕셔너리로 리턴한다.
```python
a = [1,2,3,4,5,5,5,6,6]
b = collections.Counter(a)
print(b) # {5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1}
print(b.most_common(1)) # [(5, 3)] 가장높은 빈도 요소 추출
```

### OrderedDict 객체
현재는 딕셔너리가 순서가 유지되지만 과거 유지가 되지않았기 때문에 OrderedDict를 사용하였다.  
현재는 사용되지 않으며 하위 호환성을 위하여 남겨져있다. 그러나 하위 버전의 인터프리터를 사용할 때 사용할 것을 인지해 두어야한다.